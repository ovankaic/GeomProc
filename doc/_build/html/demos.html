<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Demos &mdash; GeomProc 1.7 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User Guide" href="userguide.html" />
    <link rel="prev" title="Welcome to GeomProc’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            GeomProc
          </a>
              <div class="version">
                1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Demos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#load-a-mesh-and-visualize-normal-vectors">Load a mesh and visualize normal vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#visualize-mesh-degree">Visualize mesh degree</a></li>
<li class="toctree-l2"><a class="reference internal" href="#curvature-computation">Curvature computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mesh-smoothing">Mesh smoothing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mesh-parameterization">Mesh parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sample-a-mesh">Sample a mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="#estimate-normals-of-a-point-cloud">Estimate normals of a point cloud</a></li>
<li class="toctree-l2"><a class="reference internal" href="#align-two-point-clouds">Align two point clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reconstruction-of-an-implicit-surface">Reconstruction of an implicit surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rbf-surface-reconstruction">RBF surface reconstruction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#approximate-geodesic-distances">Approximate geodesic distances</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="userguide.html">User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="geomproc.html">geomproc package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GeomProc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Demos</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/demos.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="demos">
<h1>Demos<a class="headerlink" href="#demos" title="Permalink to this heading"></a></h1>
<p>Note in these code listings that there is no need to load submodules of
the library, as all the classes and functions in the submodules are made
visible as part of the package <em>geomproc</em>.</p>
<section id="load-a-mesh-and-visualize-normal-vectors">
<h2>Load a mesh and visualize normal vectors<a class="headerlink" href="#load-a-mesh-and-visualize-normal-vectors" title="Permalink to this heading"></a></h2>
<p>test_mesh.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a mesh and compute some geometric information</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Save normalized mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>

<span class="c1"># Compute normal vectors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>

<span class="c1"># Create geometry for normals</span>

<span class="c1"># Vertex normals</span>
<span class="n">vn</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_vectors</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">vnormal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Face normals</span>
<span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+</span> \
            <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+</span> \
            <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:])</span><span class="o">/</span><span class="mf">3.0</span>
<span class="n">fn</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_vectors</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">fnormal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c1"># Save the meshes for normals</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">vn</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_vnormal.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
<span class="n">fn</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_fnormal.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Combine all geometries into one, if needed</span>
<span class="c1">#tm.append(vn)</span>
<span class="c1">#tm.append(fn)</span>
<span class="c1">#tm.save(&#39;output/bunny_all.obj&#39;, wo)</span>
</pre></div>
</div>
<p>Result: bunny with vertex normals (blue) and face normals (red)</p>
<a class="reference internal image-reference" href="_images/bunny_normals.png"><img alt="Bunny with vertex normals (blue) and face normals (red)" src="_images/bunny_normals.png" style="width: 320px;" /></a>
</section>
<section id="visualize-mesh-degree">
<h2>Visualize mesh degree<a class="headerlink" href="#visualize-mesh-degree" title="Permalink to this heading"></a></h2>
<p>test_degree.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Color a mesh according to the degrees of its vertices</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for creating data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Compute connectivity information</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">()</span>

<span class="c1"># Collect vertex degrees</span>
<span class="n">degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">viv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Color the mesh according to degrees</span>
<span class="n">tm</span><span class="o">.</span><span class="n">data_to_color</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Save the mesh</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_degree.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: deviation from degree 6 shown with colors</p>
<a class="reference internal image-reference" href="_images/bunny_degree.png"><img alt="Bunny with degree denoted by color" src="_images/bunny_degree.png" style="width: 320px;" /></a>
</section>
<section id="curvature-computation">
<h2>Curvature computation<a class="headerlink" href="#curvature-computation" title="Permalink to this heading"></a></h2>
<p>Curvature comparison on various primitive surfaces: test_curvature.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute curvature values for a variety of analytical shapes</span>
<span class="c1">#</span>
<span class="c1"># Use the results to compare curvature values computed analytically to</span>
<span class="c1"># curvature values computed from the mesh</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import os library for checking the output directory</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Check if output directory exists</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">)</span>

<span class="c1"># Set up write_option to save vertex colors</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Cylinder</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Change if statement to 0 to disable this block</span>
    <span class="n">cylinder</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_cylinder</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">cylinder</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cylinder</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">cylinder</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cylinder_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">cylinder</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cylinder</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">cylinder</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cylinder_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">cylinder2</span> <span class="o">=</span> <span class="n">cylinder</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">cylinder2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">cylinder2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cylinder2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">cylinder2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cylinder_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">cylinder2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cylinder2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">cylinder2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cylinder_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Sphere</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">sphere</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_sphere</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="n">sphere</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">sphere</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/sphere_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">sphere</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">sphere</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/sphere_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">sphere2</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sphere2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">sphere2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">sphere2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">sphere2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/sphere_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">sphere2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">sphere2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">sphere2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/sphere_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Cone</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">cone</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_cone</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">cone</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cone</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">cone</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cone_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">cone</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cone</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">cone</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cone_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">cone2</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">cone2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">cone2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cone2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">cone2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cone_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">cone2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">cone2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">cone2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/cone_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Torus</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">torus</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_torus</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="n">torus</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">torus</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">torus</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/torus_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">torus</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">torus</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">torus</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/torus_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">torus2</span> <span class="o">=</span> <span class="n">torus</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">torus2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">torus2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">torus2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">torus2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/torus_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">torus2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">torus2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">torus2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/torus_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Saddle</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">saddle</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_open_surface</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">saddle</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">saddle</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">saddle</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/saddle_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">saddle</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">saddle</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">saddle</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/saddle_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">saddle2</span> <span class="o">=</span> <span class="n">saddle</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">saddle2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">saddle2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">saddle2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">saddle2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/saddle_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">saddle2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">saddle2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">saddle2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/saddle_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Monkey saddle</span>
<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">monkey_saddle</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_open_surface</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">monkey_saddle</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">monkey_saddle</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">monkey_saddle</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/monkey_saddle_mean_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">monkey_saddle</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">monkey_saddle</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">monkey_saddle</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/monkey_saddle_gaussian_analytic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="n">monkey_saddle2</span> <span class="o">=</span> <span class="n">monkey_saddle</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>
    <span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/monkey_saddle_mean_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">monkey_saddle2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/monkey_saddle_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
<p>Curvature comparison on a shape with and without noise:
test_curvature_with_noise.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute curvature values for a given mesh and its noisy version</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import os library for checking the output directory</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Check if output directory exists</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">)</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Compute curvature of the mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>

<span class="c1"># Set up write_option to save vertex colors</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Save curvature information as colors of a mesh</span>
<span class="p">[</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/bunny_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Add noise to the mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">add_noise</span><span class="p">(</span><span class="mf">0.02</span><span class="p">);</span>

<span class="c1"># Recompute curvature of the mesh</span>
<span class="c1"># Note: we also need to recompute normals</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_curvature</span><span class="p">()</span>

<span class="c1"># Save curvature information as colors of a mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">data_to_color_with_zero</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">curv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="n">mn</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="n">mx</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;curv/bunny_with_noise_gaussian_discrete.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: curvature plot on bunny without and with noise</p>
<a class="reference internal image-reference" href="_images/bunny_curvature.png"><img alt="Bunny with colors denoting Gaussian curvature" src="_images/bunny_curvature.png" style="width: 320px;" /></a>
<a class="reference internal image-reference" href="_images/bunny_with_noise_curvature.png"><img alt="Noisy bunny with colors denoting Gaussian curvature" src="_images/bunny_with_noise_curvature.png" style="width: 320px;" /></a>
</section>
<section id="mesh-smoothing">
<h2>Mesh smoothing<a class="headerlink" href="#mesh-smoothing" title="Permalink to this heading"></a></h2>
<p>With averaging method: test_smoothing.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Smooth a mesh with an averaging algorithm</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Load the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>

<span class="c1"># Compute connectivity information</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">()</span>

<span class="c1"># Perform smoothing</span>
<span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="c1"># Temporary holder for smoothed vertex positions</span>
<span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># Smoothing iterations</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
    <span class="c1"># Smooth each vertex</span>
    <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Save averaged position</span>
        <span class="n">smooth</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">viv</span><span class="p">[</span><span class="n">vi</span><span class="p">],</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Update all vertex position with averaged positions</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">smooth</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Save the mesh</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_smooth.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
<p>With Laplacian operator: test_smoothing_with_operator.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Smooth a mesh with the Laplacian operator</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Load the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Compute connectivity information</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">()</span>

<span class="c1"># Perform smoothing with different operators</span>
<span class="n">lap_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lap_types</span><span class="p">)):</span>
    <span class="c1"># Build operator</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">uniform_laplacian</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">[</span><span class="n">L</span><span class="p">,</span> <span class="n">negative</span><span class="p">,</span> <span class="n">boundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">geometric_laplacian</span><span class="p">()</span>

    <span class="c1"># Apply operator</span>
    <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">)</span>

    <span class="c1"># Save resulting mesh</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_smooth_&#39;</span> <span class="o">+</span> <span class="n">lap_types</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.obj&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: smooth bunny obtained with uniform and geometric Laplacians</p>
<a class="reference internal image-reference" href="_images/bunny_smooth_uniform.png"><img alt="Smooth bunny obtained with uniform Laplacian" src="_images/bunny_smooth_uniform.png" style="width: 320px;" /></a>
<a class="reference internal image-reference" href="_images/bunny_smooth_geometric.png"><img alt="Smooth bunny obtained with geometric Laplacian" src="_images/bunny_smooth_geometric.png" style="width: 320px;" /></a>
</section>
<section id="mesh-parameterization">
<h2>Mesh parameterization<a class="headerlink" href="#mesh-parameterization" title="Permalink to this heading"></a></h2>
<p>test_tutte_embedding.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Demo of computing a parameterization with Tutte&#39;s embedding</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import math for miscellaneous mathematical functions</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">def</span> <span class="nf">map_boundary_to_circle</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">bnd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map the vertices of a boundary to a circle in the given order</span>
<span class="sd">   </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tm : mesh</span>
<span class="sd">        Mesh object for the input shape</span>
<span class="sd">    bnd : array_like</span>
<span class="sd">        List of vertices representing the boundary to be used for the</span>
<span class="sd">        parameterization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : array_like</span>
<span class="sd">        Array of shape n x 2, where n is the number of vertices in the</span>
<span class="sd">        mesh. The array holds the 2D coordinates of each vertex of the</span>
<span class="sd">        boundary mapped to a circle. Vertices that are not on the</span>
<span class="sd">        boundary are assigned a coordinate [0, 0]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method maps a list of vertices along a boundary to a circle of</span>
<span class="sd">    radius 0.5 centered at (0.5, 0.5), so that the entire mesh fits</span>
<span class="sd">    within the range [0:1, 0:1] required for texture coordinates. The</span>
<span class="sd">    list of boundary vertices has to be given in sequential order around</span>
<span class="sd">    the boundary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Get length of the boundary</span>
    <span class="n">lgt</span> <span class="o">=</span> <span class="n">bnd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Initialize output coordinates</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Specify points along a circle</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">lgt</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lgt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">bnd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">increment</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">increment</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">u</span>


<span class="k">def</span> <span class="nf">param_matrix</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">lap_type</span><span class="p">,</span> <span class="n">bnd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the matrix needed for Tutte embedding based on the given boundary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tm : mesh</span>
<span class="sd">        Mesh object for the input shape</span>
<span class="sd">    lap_type : string</span>
<span class="sd">        The type of Laplacian operator used for creating the</span>
<span class="sd">        parameterization matrix. It can be either &#39;uniform&#39; or</span>
<span class="sd">        &#39;geometric&#39;</span>
<span class="sd">    bnd : array_like</span>
<span class="sd">        List of vertices representing the boundary to be used for the</span>
<span class="sd">        parameterization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : array_like</span>
<span class="sd">        Parameterization matrix that can be used for computing a Tutte</span>
<span class="sd">        embedding</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The method builds a matrix that can be used for computing a Tutte</span>
<span class="sd">    parameterization of a mesh. The vertices on the boundary are fixed</span>
<span class="sd">    to positions around a circle, while other vertices are constrained</span>
<span class="sd">    according to the operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Select the type of operator to use and create corresponding matrix</span>
    <span class="k">if</span> <span class="n">lap_type</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">uniform_laplacian</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">lap_type</span> <span class="o">==</span> <span class="s1">&#39;geometric&#39;</span><span class="p">:</span>
        <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">negative</span><span class="p">,</span> <span class="n">boundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">geometric_laplacian</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid type of Laplacian specified: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lap_type</span><span class="p">))</span>

    <span class="c1"># Transform the operator into a parameterization matrix</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bnd</span><span class="p">)):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">bnd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">A</span><span class="p">[</span><span class="n">bnd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bnd</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">A</span>


<span class="k">def</span> <span class="nf">tutte_embedding</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">lap_type</span><span class="p">,</span> <span class="n">bnd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Tutte embedding of a mesh according to a given Laplacian</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tm : mesh</span>
<span class="sd">        Mesh object for the input shape</span>
<span class="sd">    lap_type : string</span>
<span class="sd">        The type of Laplacian operator used for creating the</span>
<span class="sd">        parameterization matrix. It can be either &#39;uniform&#39; or</span>
<span class="sd">        &#39;geometric&#39;</span>
<span class="sd">    bnd : array_like</span>
<span class="sd">        List of vertices representing the boundary to be used for the</span>
<span class="sd">        parameterization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : array_like</span>
<span class="sd">        Array of shape n x 2, where n is the number of vertices in the</span>
<span class="sd">        mesh. Each row of the array represents the 2D coordinates of a</span>
<span class="sd">        vertex in the parameterization</span>
<span class="sd">    A : array_like</span>
<span class="sd">        Parameterization matrix used for computing the Tutte embedding</span>
<span class="sd">    constr : array_like</span>
<span class="sd">        Right-hand side constraints used for solving the linear system</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Map vertices along boundary to a circle of radius 0.5 centered at</span>
    <span class="c1"># (0.5, 0.5), so that the entire mesh fits within the range [0:1,</span>
    <span class="c1"># 0:1] required for texture coordinates</span>
    <span class="n">constr</span> <span class="o">=</span> <span class="n">map_boundary_to_circle</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">bnd</span><span class="p">)</span>

    <span class="c1"># Create matrix for linear system</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">param_matrix</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">lap_type</span><span class="p">,</span> <span class="n">bnd</span><span class="p">)</span>

    <span class="c1"># Solve linear systems for u and v coordinates</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">constr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">u</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">constr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Third coordinate is left as all zeros, so that we can save the mesh</span>

    <span class="c1"># Return parameterized coordinates</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">constr</span><span class="p">]</span>


<span class="c1"># Main function</span>

<span class="c1"># Specify input mesh</span>
<span class="n">mesh_name</span> <span class="o">=</span> <span class="s1">&#39;crater&#39;</span>
<span class="c1">#mesh_name = &#39;beetle&#39;</span>
<span class="c1">#mesh_name = &#39;bunny&#39;</span>
<span class="c1">#mesh_name = &#39;camel_cut&#39;</span>

<span class="c1"># Set input and output filenames</span>
<span class="n">input_mesh</span> <span class="o">=</span> <span class="s1">&#39;meshes/&#39;</span> <span class="o">+</span> <span class="n">mesh_name</span> <span class="o">+</span> <span class="s1">&#39;.obj&#39;</span>
<span class="n">input_boundary</span> <span class="o">=</span> <span class="s1">&#39;meshes/&#39;</span> <span class="o">+</span> <span class="n">mesh_name</span> <span class="o">+</span> <span class="s1">&#39;.bnd&#39;</span>
<span class="n">output_prefix_texture</span> <span class="o">=</span> <span class="s1">&#39;output/&#39;</span> <span class="o">+</span> <span class="n">mesh_name</span> <span class="o">+</span> <span class="s1">&#39;_textured&#39;</span>
<span class="n">output_prefix_param</span> <span class="o">=</span> <span class="s1">&#39;output/&#39;</span> <span class="o">+</span> <span class="n">mesh_name</span> <span class="o">+</span> <span class="s1">&#39;_param&#39;</span>
<span class="n">output_prefix_boundary</span> <span class="o">=</span> <span class="s1">&#39;output/&#39;</span> <span class="o">+</span> <span class="n">mesh_name</span> <span class="o">+</span> <span class="s1">&#39;_boundary&#39;</span>

<span class="c1"># Load and normalize mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">input_mesh</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Load boundary</span>
<span class="n">bnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">input_boundary</span><span class="p">)</span>
<span class="n">bnd</span> <span class="o">=</span> <span class="n">bnd</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># Initialize write options</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>

<span class="c1"># Compute parameterizations with different operators</span>
<span class="n">lap_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;geometric&#39;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">lap_type</span> <span class="ow">in</span> <span class="n">lap_types</span><span class="p">:</span>

    <span class="c1"># Compute Tutte embedding</span>
    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">constr</span><span class="p">]</span> <span class="o">=</span> <span class="n">tutte_embedding</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">lap_type</span><span class="p">,</span> <span class="n">bnd</span><span class="p">)</span>

    <span class="c1"># Save mesh with the boundary highlighted</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vcolor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vcolor</span><span class="p">[</span><span class="n">bnd</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_prefix_boundary</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">lap_type</span> <span class="o">+</span> <span class="s1">&#39;.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vcolor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># Reset colors</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Reset this flag</span>

    <span class="c1"># Save textured mesh</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vuv</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_uvs</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">texture_name</span> <span class="o">=</span> <span class="s1">&#39;pattern.png&#39;</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_prefix_texture</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">lap_type</span> <span class="o">+</span> <span class="s1">&#39;.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
    <span class="n">tm</span><span class="o">.</span><span class="n">vuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># Reset this field</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_uvs</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Reset this flag</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">texture_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># Save mesh parametrized to 2D</span>
    <span class="n">param_tm</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">param_tm</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">u</span> <span class="c1"># Assign parameterized coordinates</span>
    <span class="n">param_tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_prefix_param</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">lap_type</span> <span class="o">+</span> <span class="s1">&#39;.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

    <span class="c1"># Save operator</span>
    <span class="c1">#output_prefix_operator = mesh_name + &#39;_matrix&#39;</span>
    <span class="c1">#np.savetxt(output_prefix_operator + &#39;_&#39; + lap_type + &#39;.txt&#39;, A)</span>
</pre></div>
</div>
<p>Result: parameterization of Crater Lake and texture mapping</p>
<a class="reference internal image-reference" href="_images/crater_param.png"><img alt="Parameterization of Crater Lake" src="_images/crater_param.png" style="width: 320px;" /></a>
<a class="reference internal image-reference" href="_images/pattern.png"><img alt="Texture" src="_images/pattern.png" style="width: 200px;" /></a>
<a class="reference internal image-reference" href="_images/crater_with_texture.png"><img alt="Textured Crater Lake" src="_images/crater_with_texture.png" style="width: 320px;" /></a>
</section>
<section id="sample-a-mesh">
<h2>Sample a mesh<a class="headerlink" href="#sample-a-mesh" title="Permalink to this heading"></a></h2>
<p>test_sample.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load and sample a mesh</span>

<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Save normalized mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>

<span class="c1"># Compute normal vectors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>

<span class="c1"># Sample the mesh</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

<span class="c1"># Save just the samples</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_point_normals</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">pc</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_only_samples.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Save the samples as geometry that can be visualized</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">points</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_samples.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="estimate-normals-of-a-point-cloud">
<h2>Estimate normals of a point cloud<a class="headerlink" href="#estimate-normals-of-a-point-cloud" title="Permalink to this heading"></a></h2>
<p>test_normal.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute normals of a point cloud</span>

<span class="kn">import</span> <span class="nn">geomproc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Compute normal vectors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>

<span class="c1"># Sample the mesh</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

<span class="c1"># Estimate normals</span>
<span class="n">pc_est</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">pc_est</span><span class="o">.</span><span class="n">estimate_normals_simple</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># Calculate errors between real and estimated normals</span>
<span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span> <span class="o">-</span> <span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="n">mn</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">mx</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">arg_mn</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
<span class="n">arg_mx</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Simple normal estimation&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Minimum error: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; for normals &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mn</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mn</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; at index &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">arg_mn</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Maximum error: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; for normals &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mx</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mx</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; at index &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">arg_mx</span><span class="p">))</span>

<span class="c1"># Estimate normals</span>
<span class="n">pc_est2</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">pc_est2</span><span class="o">.</span><span class="n">estimate_normals</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># Calculate errors between real and estimated normals</span>
<span class="n">dist2</span> <span class="o">=</span> <span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span> <span class="o">-</span> <span class="n">pc_est2</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span>
<span class="n">mn2</span> <span class="o">=</span> <span class="n">dist2</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="n">mx2</span> <span class="o">=</span> <span class="n">dist2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">arg_mn2</span> <span class="o">=</span> <span class="n">dist2</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
<span class="n">arg_mx2</span> <span class="o">=</span> <span class="n">dist2</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Normal estimation with flipping&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Minimum error: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mn2</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; for normals &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mn2</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mn2</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; at index &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">arg_mn2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Maximum error: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mx2</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; for normals &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mx2</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; and &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">arg_mx2</span><span class="p">,</span> <span class="p">:])</span><span class="o">+</span><span class="s1">&#39; at index &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">arg_mx2</span><span class="p">))</span>


<span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dist2</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Vertex normals</span>
<span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">pnt</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_vectors</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">pc</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">vec2</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_vectors</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">pc_est</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">vec3</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_vectors</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">pc_est2</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pnt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="n">pnt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
    <span class="n">pnt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec3</span><span class="p">)</span>

<span class="c1"># Save the mesh</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">pnt</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_nv.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Save samples</span>
<span class="c1">#pc.save(&#39;output/bunny_samples.ply&#39;)</span>
</pre></div>
</div>
</section>
<section id="align-two-point-clouds">
<h2>Align two point clouds<a class="headerlink" href="#align-two-point-clouds" title="Permalink to this heading"></a></h2>
<p>With the ICP method: test_icp.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Align two point clouds with the ICP algorithm</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Math functions</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="c1"># Default setting: 1000 points and 50 iterations</span>
<span class="c1">#</span>
<span class="c1"># Things to try:</span>
<span class="c1"># - A Completely random transformation</span>
<span class="c1"># - A different set of samples for pc2 (call tm.sample() again)</span>
<span class="c1"># - Estimate normals instead of using mesh normals</span>
<span class="c1"># - More points and iterations</span>


<span class="c1">#### Create a point sample for the test</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Sample a set of points from the surface of the mesh</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">pc1</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Apply a transformation to pc1 to create pc2</span>
<span class="c1"># Define the transformation</span>
<span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># Choose the transformation by switching True/False</span>
    <span class="c1"># Choose a completely random transformation</span>
    <span class="n">orig_rot</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">rotation_random</span><span class="p">()</span>
    <span class="n">orig_trans</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">translation_random</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Choose a specific rotation around the y axis</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">orig_rot</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">rotation_y</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">orig_trans</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Apply the transformation to pc1 to create the second point cloud pc2</span>
<span class="n">pc2</span> <span class="o">=</span> <span class="n">pc1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="c1"># For a more realistic example, pc2 could be another set of samples</span>
<span class="c1"># pc2 = tm.sample(n)</span>
<span class="n">pc2</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">pc2</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">orig_rot</span><span class="p">,</span> <span class="n">orig_trans</span><span class="p">)</span>

<span class="c1"># Save input data</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>
<span class="n">pc1</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample1.obj&#39;</span><span class="p">)</span>
<span class="n">pc2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample2.obj&#39;</span><span class="p">)</span>


<span class="c1">#### Align the point clouds</span>

<span class="c1"># Run the ICP method</span>
<span class="n">error_threshold</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">num_iters</span> <span class="o">=</span> <span class="mi">50</span>
<span class="p">[</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">pc1tr</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">iter_count</span><span class="p">,</span> <span class="n">corr</span><span class="p">]</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">icp</span><span class="p">(</span><span class="n">pc1</span><span class="p">,</span> <span class="n">pc2</span><span class="p">,</span> <span class="n">error_threshold</span><span class="p">,</span> <span class="n">num_iters</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>

<span class="c1"># Save registration</span>
<span class="n">pc1tr</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample1aligned.obj&#39;</span><span class="p">)</span>

<span class="c1"># Save final correspondence so that we can see it</span>
<span class="k">if</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># Turn on/off with True/False</span>
    <span class="c1"># Create lines to indicate the correspondences</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pc1</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pc1tr</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">pc2</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]))</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_lines</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
    <span class="c1"># Create points for the point sets</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc1tr</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pt2</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc1</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pt3</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc2</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Combine everything together</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt3</span><span class="p">)</span>
    <span class="c1"># Save the mesh</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_corr.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Print some information</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Original transformation = &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">orig_rot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">orig_trans</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Alignment result = &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of iterations used = &#39;</span><span class="p">,</span> <span class="n">iter_count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error after alignment = &#39;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: green samples transformed to red samples to align with blue
samples</p>
<a class="reference internal image-reference" href="_images/bunny_aligned.png"><img alt="Aligned samples of bunny model" src="_images/bunny_aligned.png" style="width: 320px;" /></a>
<p>With descriptor matching: test_spin_images.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Align two point clouds with descriptor matching</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Math functions</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="c1">#### Create point samples for the test</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm1</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm1</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Apply a transformation to the mesh to create a misaligned version</span>
<span class="c1"># Define the transformation</span>
<span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># Choose the transformation by switching True/False</span>
    <span class="c1"># Choose a completely random transformation</span>
    <span class="n">rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">rnd</span><span class="p">)</span>
    <span class="n">orig_rot</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">orig_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Choose a specific rotation around the y axis</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">orig_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)]])</span>
    <span class="n">orig_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Copy the mesh and apply the transformation to the mesh</span>
<span class="n">tm2</span> <span class="o">=</span> <span class="n">tm1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">tm2</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">tm1</span><span class="o">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">orig_rot</span><span class="p">,</span> <span class="n">orig_trans</span><span class="p">)</span>
<span class="c1"># Update normals: important! As the spin images descriptor depends on them</span>
<span class="n">tm2</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span> 

<span class="c1"># Sample two sets of points from the surfaces of the meshes</span>
<span class="n">n1</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1"># We are going to compute a descriptor for each of these points</span>
<span class="n">n2</span> <span class="o">=</span> <span class="mi">10000</span> <span class="c1"># We are going to use these points only for reference in the descriptor computation</span>
<span class="n">pc1</span> <span class="o">=</span> <span class="n">tm1</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
<span class="n">pc1full</span> <span class="o">=</span> <span class="n">tm1</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="n">pc2</span> <span class="o">=</span> <span class="n">tm2</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
<span class="n">pc2full</span> <span class="o">=</span> <span class="n">tm2</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>

<span class="c1"># Save input data</span>
<span class="n">tm1</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>
<span class="n">pc1</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample1.obj&#39;</span><span class="p">)</span>
<span class="n">pc2</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample2.obj&#39;</span><span class="p">)</span>


<span class="c1">#### Align the point clouds</span>

<span class="c1"># Compute the spin images descriptor for the two point clouds</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">spin_image_options</span><span class="p">()</span>
<span class="n">desc1</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">spin_images</span><span class="p">(</span><span class="n">pc1</span><span class="p">,</span> <span class="n">pc1full</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
<span class="n">desc2</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">spin_images</span><span class="p">(</span><span class="n">pc2</span><span class="p">,</span> <span class="n">pc2full</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>

<span class="c1"># Match the descriptors</span>
<span class="n">corr</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">best_match</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span> <span class="n">desc2</span><span class="p">)</span>
<span class="n">corr</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">filter_correspondences</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Derive a transformation from the point match</span>
<span class="p">[</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">]</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">transformation_from_correspondences</span><span class="p">(</span><span class="n">pc1</span><span class="p">,</span> <span class="n">pc2</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span>

<span class="c1"># Apply the transformation to align the meshes</span>
<span class="n">pc1tr</span> <span class="o">=</span> <span class="n">pc1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">pc1tr</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">pc1</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>

<span class="c1"># Save registration</span>
<span class="n">pc1tr</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_sample1aligned.obj&#39;</span><span class="p">)</span>

<span class="c1"># Save final correspondence so that we can see it</span>
<span class="k">if</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># Turn on/off with True/False</span>
    <span class="c1"># Create lines to indicate the correspondences</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pc1tr</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:],</span> <span class="n">pc2</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]))</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_lines</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
    <span class="c1"># Create points for the point sets</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc1tr</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pt2</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc1</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pt3</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">create_points</span><span class="p">(</span><span class="n">pc2</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Combine everything together</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt3</span><span class="p">)</span>
    <span class="c1"># Save the mesh</span>
    <span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
    <span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_corr.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Print some information</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Original transformation = &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">orig_rot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">orig_trans</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Alignment result = &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="reconstruction-of-an-implicit-surface">
<h2>Reconstruction of an implicit surface<a class="headerlink" href="#reconstruction-of-an-implicit-surface" title="Permalink to this heading"></a></h2>
<p>test_reconstruction.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test reconstruction of an implicit function with the marching cubes</span>
<span class="c1"># algorithm</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Set up an implicit function for a surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">impsurf</span><span class="p">()</span>
<span class="c1">#surf.setup_sphere(0.5)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">setup_torus</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Reconstruct the surface</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">marching_cubes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">32</span><span class="p">,</span> <span class="n">surf</span><span class="o">.</span><span class="n">evaluate</span><span class="p">)</span>

<span class="c1"># Save surface</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/reconstruction.obj&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: torus reconstructed from implicit function</p>
<a class="reference internal image-reference" href="_images/torus_rec.png"><img alt="Reconstruction of a torus" src="_images/torus_rec.png" style="width: 320px;" /></a>
</section>
<section id="rbf-surface-reconstruction">
<h2>RBF surface reconstruction<a class="headerlink" href="#rbf-surface-reconstruction" title="Permalink to this heading"></a></h2>
<p>Simple version: test_rbf.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test reconstruction of a set of samples with the RBF method</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import math functions</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># Measure execution time</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Save normalized mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>

<span class="c1"># Compute normal vectors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>

<span class="c1"># Sample a point cloud from the mesh</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Define kernel for reconstruction</span>
<span class="c1">#kernel = lambda x, y: math.pow(np.linalg.norm(x - y), 3)</span>
<span class="n">wendland</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="o">/</span><span class="n">h</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">wendland</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># Define epsilon for displacing samples</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span>

<span class="c1"># Run RBF reconstruction</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reconstructing implicit function&#39;</span><span class="p">)</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">impsurf</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">setup_rbf</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

<span class="c1"># Run marching cubes</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running marching cubes&#39;</span><span class="p">)</span>
<span class="n">rec</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">marching_cubes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]),</span> <span class="mi">16</span><span class="p">,</span> <span class="n">surf</span><span class="o">.</span><span class="n">evaluate</span><span class="p">)</span>

<span class="c1"># Report time</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Execution time = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>

<span class="c1"># Save output mesh</span>
<span class="n">rec</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_rec.obj&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Faster, vectorized version: test_rbf_vectorized.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test reconstruction of a set of samples with the RBF method</span>

<span class="c1"># Import geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Import math functions</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># Measure execution time</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Save normalized mesh</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_normalized.obj&#39;</span><span class="p">)</span>

<span class="c1"># Compute normal vectors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_vertex_and_face_normals</span><span class="p">()</span>

<span class="c1"># Sample a point cloud from the mesh</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Define vectorized kernel for reconstruction</span>
<span class="n">euclidean</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="mf">3.0</span><span class="p">)</span>

<span class="c1"># Define epsilon for displacing samples</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span>

<span class="c1"># Run RBF reconstruction</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reconstructing implicit function&#39;</span><span class="p">)</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">impsurf</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">setup_rbf</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Run marching cubes</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running marching cubes&#39;</span><span class="p">)</span>
<span class="n">rec</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">marching_cubes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]),</span> <span class="mi">64</span><span class="p">,</span> <span class="n">surf</span><span class="o">.</span><span class="n">evaluate</span><span class="p">)</span>

<span class="c1"># Report time</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Execution time = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>

<span class="c1"># Save output mesh</span>
<span class="n">rec</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_rec.obj&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="approximate-geodesic-distances">
<h2>Approximate geodesic distances<a class="headerlink" href="#approximate-geodesic-distances" title="Permalink to this heading"></a></h2>
<p>test_geodesic.py</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Approximate geodesic distances on a mesh by computing graph distances</span>

<span class="c1"># Import the geometry processing library</span>
<span class="kn">import</span> <span class="nn">geomproc</span>

<span class="c1"># Import numpy for creating data arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Load and normalize the mesh</span>
<span class="n">tm</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meshes/bunny.obj&#39;</span><span class="p">)</span>
<span class="n">tm</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Compute connectivity information</span>
<span class="n">tm</span><span class="o">.</span><span class="n">compute_connectivity</span><span class="p">()</span>

<span class="c1"># Compute graph distances on mesh vertices</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="c1"># Adjacency is vertex neighborhood</span>
<span class="n">graph</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">viv</span>
<span class="c1"># Weights are lengths of edges between vertices</span>
<span class="n">graph</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">viv</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">viv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="p">:])</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="c1"># Source vertex is arbitrarily set to index 0. Modify freely</span>
<span class="n">source</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Compute shortest paths</span>
<span class="n">sp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">compute_shortest_paths</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="c1"># Map graph distances to vertex colors</span>
<span class="n">tm</span><span class="o">.</span><span class="n">data_to_color</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Save the mesh with the colors</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_vgeodesic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>

<span class="c1"># Compute graph distances on mesh faces</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="c1"># Adjacency is face neighborhood</span>
<span class="n">graph</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">fif</span>
<span class="c1"># Weights are distances between face centroids</span>
<span class="n">graph</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">fif</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
        <span class="n">centroid1</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">centroid2</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">face</span><span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">fif</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="p">:]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">centroid1</span><span class="p">,</span> <span class="n">centroid2</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="c1"># Source face is arbitrarily set to index 0. Modify freely</span>
<span class="n">source</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Compute shortest paths</span>
<span class="n">sp</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">compute_shortest_paths</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="c1"># Map graph distances to colors of vertices</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">data_face_to_vertex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">tm</span><span class="o">.</span><span class="n">data_to_color</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># Save the mesh with the colors</span>
<span class="n">wo</span> <span class="o">=</span> <span class="n">geomproc</span><span class="o">.</span><span class="n">write_options</span><span class="p">()</span>
<span class="n">wo</span><span class="o">.</span><span class="n">write_vertex_colors</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">tm</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;output/bunny_fgeodesic.obj&#39;</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
</pre></div>
</div>
<p>Result: approximate geodesic distance from a source vertex (blue region)</p>
<a class="reference internal image-reference" href="_images/bunny_geodesic.png"><img alt="Bunny with color denoting geodesic distances" src="_images/bunny_geodesic.png" style="width: 320px;" /></a>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to GeomProc’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="userguide.html" class="btn btn-neutral float-right" title="User Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Oliver van Kaick.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>